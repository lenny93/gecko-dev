diff --git a/browser/base/content/browser-context.inc b/browser/base/content/browser-context.inc
index f9fd961..40c5c87 100644
--- a/browser/base/content/browser-context.inc
+++ b/browser/base/content/browser-context.inc
@@ -38,6 +38,7 @@
       </menugroup>
       <menuseparator id="context-sep-navigation"/>
       <menuseparator id="page-menu-separator"/>
+      <menuseparator id="grammar-suggestion-separator"/>
       <menuitem id="spell-no-suggestions"
                 disabled="true"
                 label="&spellNoSuggestions.label;"/>
@@ -393,6 +394,11 @@
                 type="checkbox"
                 accesskey="&spellCheckToggle.accesskey;"
                 oncommand="InlineSpellCheckerUI.toggleEnabled(window);"/>
+      <menuitem id="grammar-check-enabled"
+                label="&grammarCheckToggle.label;"
+                type="checkbox"
+                accesskey="&grammarCheckToggle.accesskey;"
+                oncommand="gContextMenu.grammarCheckToggle();"/>
       <menuitem id="spell-add-dictionaries-main"
                 label="&spellAddDictionaries.label;"
                 accesskey="&spellAddDictionaries.accesskey;"
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
index a6cde8b..441fc1a 100644
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -14,6 +14,9 @@ XPCOMUtils.defineLazyModuleGetter(this, "Pocket",
   "resource:///modules/Pocket.jsm");
 
 var gContextMenuContentData = null;
+var gcSvc = Components.classes["@mozilla.org/grammarcheck;1"].getService(Components.interfaces.nsIEditorGrammarCheck);
+var rangeOffset;
+var mGrammarSuggestions = [];
 
 function nsContextMenu(aXulMenu, aIsShift) {
   this.shouldDisplay = true;
@@ -430,9 +433,12 @@ nsContextMenu.prototype = {
     var onMisspelling = InlineSpellCheckerUI.overMisspelling;
     var showUndo = canSpell && InlineSpellCheckerUI.canUndo();
     this.showItem("spell-check-enabled", canSpell);
+    this.showItem("grammar-check-enabled", true);
     this.showItem("spell-separator", canSpell || this.onEditableArea);
     document.getElementById("spell-check-enabled")
             .setAttribute("checked", canSpell && InlineSpellCheckerUI.enabled);
+	document.getElementById("grammar-check-enabled").setAttribute("checked", gcSvc.isGrammarCheckEnabled());
+			
 
     this.showItem("spell-add-to-dictionary", onMisspelling);
     this.showItem("spell-undo-add-to-dictionary", showUndo);
@@ -468,6 +474,68 @@ nsContextMenu.prototype = {
     else
       this.showItem("spell-add-dictionaries-main", false);
   },
+  
+  grammarCheckToggle: function() {
+	gcSvc.toggleEnabled();
+  },
+  
+  doGrammarCorrection: function(index)
+  {
+	gcSvc.doGrammarCorrection(this.mWordOffset, index);
+  },
+  
+  initGrammarItems: function(aEditor, rangeParent, rangeOffset) {	
+	var gramSuggestions = gcSvc.getSuggestionsForOffset(aEditor, rangeOffset);
+	var gramDescriptions = gcSvc.getDescriptionsForOffset(aEditor, rangeOffset);
+	this.mWordOffset = rangeOffset;
+	var separator = document.getElementById("grammar-suggestion-separator");
+	var itemNoSuggestion = document.getElementById("grammar-no-suggestions");
+	var menu = separator.parentNode;
+	
+	var index;
+	for(index = 0; index < mGrammarSuggestions.length; index++)
+	{
+		menu.removeChild(mGrammarSuggestions[index]);
+	}
+	
+	mGrammarSuggestions = [];
+	
+	for(index = 0; index < gramSuggestions.length; index++)
+	{
+		var gs = gramSuggestions.queryElementAt(index, Components.interfaces.nsISupportsString);
+		var gd = gramDescriptions.queryElementAt(index, Components.interfaces.nsISupportsString);
+		var messageOnly = gcSvc.isSuggestionMessageOnly(rangeOffset, index);
+		
+		var item = menu.ownerDocument.createElement("menuitem");
+		item.setAttribute("label", gs.data);
+		item.setAttribute("value", gs.data);
+		item.setAttribute("tooltip", gd.data);
+		item.setAttribute("tooltiptext", gd.data);
+		item.setAttribute("class", "spell-suggestion");
+		
+		if(messageOnly)
+		{
+			item.setAttribute("disabled", true);
+		}
+		else
+		{			
+			var callback = function(me, val) { return function(evt) { me.doGrammarCorrection(val); } };
+			item.addEventListener("command", callback(this, index), true);			
+		}
+		menu.insertBefore(item, separator);
+		mGrammarSuggestions.push(item);
+		
+	}
+	
+	if(gramSuggestions.length > 0)
+	{
+		this.showItem("grammar-suggestion-separator", true);
+	}
+	else
+	{
+		this.showItem("grammar-suggestion-separator", false);	
+	}
+  },
 
   initClipboardItems: function() {
     // Copy depends on whether there is selected text.
@@ -732,6 +800,7 @@ nsContextMenu.prototype = {
           else {
             InlineSpellCheckerUI.init(this.target.QueryInterface(Ci.nsIDOMNSEditableElement).editor);
             InlineSpellCheckerUI.initFromEvent(aRangeParent, aRangeOffset);
+			this.initGrammarItems(this.target.QueryInterface(Ci.nsIDOMNSEditableElement).editor, aRangeParent, aRangeOffset);
           }
         }
         this.onKeywordField = (editFlags & SpellCheckHelper.KEYWORD);
@@ -864,6 +933,7 @@ nsContextMenu.prototype = {
                                         .getInterface(Ci.nsIEditingSession);
           InlineSpellCheckerUI.init(editingSession.getEditorForWindow(targetWin));
           InlineSpellCheckerUI.initFromEvent(aRangeParent, aRangeOffset);
+		  this.initGrammarItems(editingSession.getEditorForWindow(targetWin), aRangeParent, aRangeOffset);
         }
         var canSpell = InlineSpellCheckerUI.canSpellCheck && this.canSpellCheck;
         this.showItem("spell-check-enabled", canSpell);
@@ -871,7 +941,7 @@ nsContextMenu.prototype = {
       }
     }
   },
-
+  
   // Returns the computed style attribute for the given element.
   getComputedStyle: function(aElem, aProp) {
     return aElem.ownerDocument
diff --git a/dom/base/nsISelectionController.idl b/dom/base/nsISelectionController.idl
index b28ee6b..acf1e16 100644
--- a/dom/base/nsISelectionController.idl
+++ b/dom/base/nsISelectionController.idl
@@ -29,7 +29,8 @@ interface nsISelectionController : nsISelectionDisplay
    const short SELECTION_ACCESSIBILITY=64; // For accessibility API usage
    const short SELECTION_FIND=128;
    const short SELECTION_URLSECONDARY=256;
-   const short NUM_SELECTIONTYPES=10;
+   const short SELECTION_GRAMMARCHECK=512;
+   const short NUM_SELECTIONTYPES=11;
 
    const short SELECTION_ANCHOR_REGION = 0;
    const short SELECTION_FOCUS_REGION = 1;
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
index aea672e..be73c42 100644
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -112,6 +112,7 @@
 
 // input type=date
 #include "js/Date.h"
+#include "../composer/nsEditorGrammarCheck.h"
 
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 
@@ -7308,6 +7309,11 @@ HTMLInputElement::OnValueChanged(bool aNotify)
   if (HasDirAuto()) {
     SetDirectionIfAuto(true, aNotify);
   }
+  
+  if (nsEditorGrammarCheck::GetGrammarCheckService()->mEditor == this->GetEditor())
+  {
+	  nsEditorGrammarCheck::GetGrammarCheckService()->DoGrammarCheck();
+  }
 }
 
 NS_IMETHODIMP_(bool)
diff --git a/dom/html/HTMLTextAreaElement.cpp b/dom/html/HTMLTextAreaElement.cpp
index 6ca702a..7d6328f 100644
--- a/dom/html/HTMLTextAreaElement.cpp
+++ b/dom/html/HTMLTextAreaElement.cpp
@@ -41,6 +41,7 @@
 #include "nsStyleConsts.h"
 #include "nsTextEditorState.h"
 #include "nsIController.h"
+#include "../composer/nsEditorGrammarCheck.h"
 
 static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
 
@@ -1536,6 +1537,11 @@ HTMLTextAreaElement::OnValueChanged(bool aNotify)
   if (validBefore != IsValid()) {
     UpdateState(aNotify);
   }
+  
+  if (nsEditorGrammarCheck::GetGrammarCheckService()->mEditor == this->GetEditor())
+  {
+	  nsEditorGrammarCheck::GetGrammarCheckService()->DoGrammarCheck();
+  }
 }
 
 NS_IMETHODIMP_(bool)
diff --git a/editor/composer/moz.build b/editor/composer/moz.build
index a205a62..b2887a4 100644
--- a/editor/composer/moz.build
+++ b/editor/composer/moz.build
@@ -10,6 +10,7 @@ MOCHITEST_CHROME_MANIFESTS += ['test/chrome.ini']
 
 XPIDL_SOURCES += [
     'nsIEditingSession.idl',
+    'nsIEditorGrammarCheck.idl',
 ]
 
 XPIDL_MODULE = 'composer'
@@ -22,6 +23,7 @@ UNIFIED_SOURCES += [
     'nsComposerRegistration.cpp',
     'nsComposeTxtSrvFilter.cpp',
     'nsEditingSession.cpp',
+    'nsEditorGrammarCheck.cpp',
     'nsEditorSpellCheck.cpp',
 ]
 
diff --git a/editor/composer/nsEditorGrammarCheck.cpp b/editor/composer/nsEditorGrammarCheck.cpp
new file mode 100644
index 0000000..5a5d1fb
--- /dev/null
+++ b/editor/composer/nsEditorGrammarCheck.cpp
@@ -0,0 +1,542 @@
+#include <iostream>                 // for getenv
+#include <string.h>                     // for nullptr, strcmp
+#include "mozilla/Attributes.h"         // for final
+#include "mozilla/Preferences.h"        // for Preferences
+#include "mozilla/Services.h"           // for GetXULChromeRegistryService
+#include "mozilla/dom/Element.h"        // for Element
+#include "mozilla/dom/Selection.h"
+#include "mozilla/mozalloc.h"           // for operator delete, etc
+#include "mozilla/dom/Selection.h"
+#include "mozilla/ModuleUtils.h"
+#include "nsIEditor.h"                  // for nsIEditor
+#include "nsMemory.h"
+#include "nsIClassInfoImpl.h"
+#include "nsEditorGrammarCheck.h"
+#include "nsString.h"
+#include "nsITransferable.h"
+#include "nsXPCOMCIDInternal.h"
+#include "nsIServiceManager.h"
+#include "nsIDocumentEncoder.h"
+#include "nsIHTMLDocument.h"
+#include "nsContentCID.h"
+#include "nsGkAtoms.h"
+#include "../../modules/libpref/Preferences.h"
+
+using namespace mozilla;
+
+GC_FACTORY_SINGLETON_IMPLEMENTATION(nsEditorGrammarCheck, gGrammarCheckService)
+NS_IMPL_CLASSINFO(nsEditorGrammarCheck, nullptr, 0, NS_GRAMMARCHECK_CID)
+NS_IMPL_ISUPPORTS_CI(nsEditorGrammarCheck, nsIEditorGrammarCheck)
+
+
+nsEditorGrammarCheck::nsEditorGrammarCheck() : gCallback(nullptr), mEditor(), mCheckEnabled(true)
+{
+	NS_ASSERTION(!gGrammarCheckService,
+			   "Attempting to create two instances of the service!");
+	gGrammarCheckService = this;
+
+}
+
+nsEditorGrammarCheck::~nsEditorGrammarCheck() 
+{
+	NS_ASSERTION(gGrammarCheckService == this,
+			   "Deleting a non-singleton instance of the service");
+	if (gGrammarCheckService == this)
+		gGrammarCheckService = nullptr;
+
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::Init()
+{
+	mCheckEnabled = Preferences::GetBool("grammarCheckEnabled", true);
+	Preferences::SetBool("grammarCheckEnabled", mCheckEnabled);
+
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::RegisterAddon(nsIEditorGrammarCheckCallback* callback)
+{
+	gCallback = callback;
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::ErrorsFound(uint32_t* errorsStart, uint32_t* errorsEnd, uint32_t count)
+{
+	if (!mEditor || !mCheckEnabled || !errorsStart || !errorsEnd)
+		return NS_OK;
+
+	nsresult rv;
+
+	mErrors.clear();
+
+	nsCOMPtr<nsIDOMDocument> domDoc;
+	rv = mEditor->GetDocument(getter_AddRefs(domDoc));
+	NS_ENSURE_SUCCESS(rv, rv);
+	NS_ENSURE_TRUE(domDoc, NS_ERROR_NULL_POINTER);
+
+
+	nsCOMPtr<nsIDocument> mDocument = do_QueryInterface(domDoc);
+
+	// Find the root node for the editor. For contenteditable we'll need something
+	// cleverer here.
+	nsCOMPtr<nsIDOMElement> rootElem;
+	rv = mEditor->GetRootElement(getter_AddRefs(rootElem));
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	mRootNode = do_QueryInterface(rootElem);
+	NS_ASSERTION(mRootNode, "GetRootElement returned null *and* claimed to suceed!");
+
+	if (!mRootNode)
+		return NS_OK;
+
+	nsCOMPtr<nsISelectionController> selcon;
+	rv = mEditor->GetSelectionController(getter_AddRefs(selcon));
+
+	nsCOMPtr<nsISelection> grammarCheckSelection;
+	selcon->GetSelection(nsISelectionController::SELECTION_GRAMMARCHECK, getter_AddRefs(grammarCheckSelection));
+
+	if (!grammarCheckSelection)
+		return NS_OK;
+
+	grammarCheckSelection->RemoveAllRanges();
+	
+
+	for (int i = 0; i < count; i++)
+	{
+		nsCOMPtr<nsIDOMRange> range;
+		domDoc->CreateRange(getter_AddRefs(range));
+
+		nsCOMPtr<nsIDOMNode> aStartNode;
+		int32_t aStartOffset = 0;
+		nsCOMPtr<nsIDOMNode> aEndNode;
+		int32_t aEndOffset = -1;
+
+
+		nsCOMPtr<nsIDOMNodeList> childNodes;
+		mRootNode->GetChildNodes(getter_AddRefs(childNodes));
+
+		uint32_t childCount;
+		childNodes->GetLength(&childCount);
+
+		if (childCount < 1)
+			return NS_OK;
+
+
+		childNodes->Item(0, getter_AddRefs(aEndNode));
+		aStartNode = aEndNode;
+
+		aEndOffset = errorsEnd[i];
+		aStartOffset = errorsStart[i];
+
+
+		// sometimes we are are requested to check an empty range (possibly an empty
+		// document). This will result in assertions later.
+		if (aStartNode == aEndNode && aStartOffset == aEndOffset)
+			return NS_OK;
+
+
+		rv = range->SetStart(aStartNode, aStartOffset);
+		NS_ENSURE_SUCCESS(rv, rv);
+
+		if (aEndOffset)
+			range->SetEnd(aEndNode, aEndOffset);
+		else
+			range->SetEndAfter(aEndNode);
+
+		//nsRange* mRange = static_cast<nsRange*>(range.forget().take());
+
+
+		grammarCheckSelection->AddRange(range);
+
+		GRAMMARERROR ge;
+		ge.errorStart = errorsStart[i];
+		ge.errorEnd = errorsEnd[i];
+
+		mErrors.push_back(ge);
+	}
+
+
+	selcon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::AddSuggestionForError(uint32_t error, const nsAString& suggestion, const nsAString& description, bool messageOnly)
+{
+	if (mErrors.size() <= (int)error)
+		return NS_OK;
+
+	
+
+	mErrors[error].suggestions.push_back(nsString(suggestion));
+	mErrors[error].descriptions.push_back(nsString(description));
+	mErrors[error].messageOnly.push_back(messageOnly);
+	
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::IsSuggestionMessageOnly(uint32_t aOffset, uint32_t suggestion, bool* _retval)
+{
+	nsresult rv;
+
+	for (int i = 0; i < mErrors.size(); ++i)
+	{
+		if (mErrors[i].errorStart <= aOffset && mErrors[i].errorEnd > aOffset)
+		{
+			if (mErrors[i].suggestions.size() > (int)suggestion)
+			{
+				*_retval = mErrors[i].messageOnly[suggestion];
+			}
+			break;
+		}
+	}
+	
+
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::GetSuggestionsForOffset(nsIEditor* editor, uint32_t aOffset, nsIArray** _retval)
+{
+	nsresult rv;
+	NS_ENSURE_ARG_POINTER(_retval);
+	*_retval = nullptr;
+
+	nsCOMPtr<nsIMutableArray> array = do_CreateInstance(NS_ARRAY_CONTRACTID);
+
+	if (mEditor == editor && mCheckEnabled)
+	{
+		for (int i = 0; i < mErrors.size(); ++i)
+		{
+			if (mErrors[i].errorStart <= aOffset && mErrors[i].errorEnd > aOffset)
+			{
+				for (int j = 0; j < mErrors[i].suggestions.size(); ++j)
+				{
+					nsCOMPtr<nsISupportsString> istr = do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID);
+					istr->SetData(mErrors[i].suggestions[j]);
+					array->AppendElement(istr, PR_FALSE);
+				}
+				break;
+			}
+		}
+	}
+
+
+	array.forget(_retval);
+
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::GetDescriptionsForOffset(nsIEditor* editor, uint32_t aOffset, nsIArray** _retval)
+{
+	nsresult rv;
+	NS_ENSURE_ARG_POINTER(_retval);
+	*_retval = nullptr;
+
+	nsCOMPtr<nsIMutableArray> array = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	if (mEditor == editor && mCheckEnabled)
+	{
+		for (int i = 0; i < mErrors.size(); ++i)
+		{
+			if (mErrors[i].errorStart <= aOffset && mErrors[i].errorEnd > aOffset)
+			{
+				for (int j = 0; j < mErrors[i].descriptions.size(); ++j)
+				{
+					nsCOMPtr<nsISupportsString> istr = do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv);
+					istr->SetData(mErrors[i].descriptions[j]);
+					array->AppendElement(istr, PR_FALSE);
+				}
+				break;
+			}
+		}
+	}
+
+
+	array.forget(_retval);
+
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::DoGrammarCorrection(uint32_t aOffset, uint32_t index)
+{
+	if (mEditor && mRootNode)
+	{
+		for (int i = 0; i < mErrors.size(); ++i)
+		{
+			if (mErrors[i].errorStart <= aOffset && mErrors[i].errorEnd > aOffset)
+			{
+				nsCOMPtr<nsISelectionController> selcon;
+				mEditor->GetSelectionController(getter_AddRefs(selcon));
+
+				nsCOMPtr<nsISelection> grammarCheckSelection;
+				selcon->GetSelection(nsISelectionController::SELECTION_GRAMMARCHECK, getter_AddRefs(grammarCheckSelection));
+
+				if (!grammarCheckSelection)
+					return NS_OK;
+
+				nsCOMPtr<nsISelectionPrivate> privSel(do_QueryInterface(grammarCheckSelection));
+
+				nsTArray<nsRange*> ranges;
+
+				nsCOMPtr<nsIDOMNodeList> childNodes;
+				mRootNode->GetChildNodes(getter_AddRefs(childNodes));
+
+				uint32_t childCount;
+				childNodes->GetLength(&childCount);
+
+				nsCOMPtr<nsIDOMNode> par;
+
+				if (childCount >= 1)
+				{
+					childNodes->Item(0, getter_AddRefs(par));
+				}
+				else
+				{
+					return NS_OK;
+				}
+
+				nsCOMPtr<nsINode> node = do_QueryInterface(par);
+
+				nsresult rv = privSel->GetRangesForIntervalArray(node, aOffset, node, aOffset, true, &ranges);
+
+				nsCOMPtr<nsIDOMRange> range; 
+
+				if (ranges.Length() == 0)
+					return NS_OK; // no matches
+
+				// there may be more than one range returned, and we don't know what do
+				// do with that, so just get the first one
+				NS_ADDREF(range = ranges[0]);
+
+				if (range)
+				{
+					mEditor->BeginTransaction();
+
+					nsCOMPtr<nsISelection> selection;
+					mEditor->GetSelection(getter_AddRefs(selection));
+					selection->RemoveAllRanges();
+					selection->AddRange(range);
+					mEditor->DeleteSelection(nsIEditor::eNone, nsIEditor::eStrip);
+
+					nsCOMPtr<nsIPlaintextEditor> textEditor(do_QueryInterface(mEditor));
+					if (textEditor && mErrors[i].suggestions.size() > index)
+					{
+						textEditor->InsertText(mErrors[i].suggestions[index]);
+					}
+
+					mEditor->EndTransaction();
+				}
+
+				DoGrammarCheck();
+
+				return NS_OK;
+			}
+		}
+	}
+
+	return NS_OK;
+}
+
+
+void nsEditorGrammarCheck::SetCurrentEditor(nsIEditor* editor)
+{
+	if (!editor)
+		return;
+
+
+	mCheckEnabled = Preferences::GetBool("grammarCheckEnabled", true);
+
+	if (mEditor)
+	{
+		nsresult rv;
+
+		nsCOMPtr<nsISelectionController> selcon;
+		rv = mEditor->GetSelectionController(getter_AddRefs(selcon));
+
+		if (selcon)
+		{
+			nsCOMPtr<nsISelection> grammarCheckSelection;
+			selcon->GetSelection(nsISelectionController::SELECTION_GRAMMARCHECK, getter_AddRefs(grammarCheckSelection));
+
+			if (grammarCheckSelection)
+				grammarCheckSelection->RemoveAllRanges();
+
+
+			selcon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
+		}
+
+	}
+
+	nsWeakPtr nwp = do_GetWeakReference(editor);
+
+	mEditor = do_QueryReferent(nwp);
+
+	DoGrammarCheck();
+
+}
+
+
+NS_IMETHODIMP nsEditorGrammarCheck::ToggleEnabled()
+{
+	mCheckEnabled = !mCheckEnabled;
+	Preferences::SetBool("grammarCheckEnabled", mCheckEnabled);
+
+	if (!mEditor)
+		return NS_OK;
+
+	if (!mCheckEnabled)
+	{
+		nsresult rv;
+
+		nsCOMPtr<nsISelectionController> selcon;
+		rv = mEditor->GetSelectionController(getter_AddRefs(selcon));
+
+		if (selcon)
+		{
+			nsCOMPtr<nsISelection> grammarCheckSelection;
+			selcon->GetSelection(nsISelectionController::SELECTION_GRAMMARCHECK, getter_AddRefs(grammarCheckSelection));
+
+			if (grammarCheckSelection)
+				grammarCheckSelection->RemoveAllRanges();
+		}
+
+		selcon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
+
+	}
+	else
+	{
+		DoGrammarCheck();
+	}
+
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::IsGrammarCheckEnabled(bool* _retval)
+{
+	*_retval = mCheckEnabled;
+	return NS_OK;
+}
+
+NS_IMETHODIMP nsEditorGrammarCheck::DoGrammarCheck()
+{
+	if (mEditor == nullptr || !mCheckEnabled)
+		return NS_OK;
+
+	nsresult rv;
+	uint32_t aFlags = nsIDocumentEncoder::SkipInvisibleContent;
+
+	nsCOMPtr<nsIDOMDocument> domDoc;
+	rv = mEditor->GetDocument(getter_AddRefs(domDoc));
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	nsCOMPtr<nsIDocumentEncoder> docEncoder;
+	docEncoder = do_CreateInstance(NS_HTMLCOPY_ENCODER_CONTRACTID);
+	NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
+
+
+	// Find the root node for the editor.
+	nsCOMPtr<nsIDOMElement> rootElem;
+	rv = mEditor->GetRootElement(getter_AddRefs(rootElem));
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(rootElem, &rv);
+	NS_ASSERTION(rootNode, "GetRootElement returned null *and* claimed to suceed!");
+
+	if (!rootNode)
+		return NS_OK;
+
+	nsCOMPtr<nsINode> node = do_QueryInterface(rootNode);
+	if (nsContentUtils::IsSystemPrincipal(node->NodePrincipal()))
+	{
+		mEditor = nullptr;
+		return NS_OK;
+	}
+
+	// if it is a selection into input/textarea element or in a html content
+	// with pre-wrap style : text/plain. Otherwise text/html.
+	// see nsHTMLCopyEncoder::SetSelection
+	nsAutoString mimeType;
+	mimeType.AssignLiteral(kTextMime);
+
+	// Do the first and potentially trial encoding as preformatted and raw.
+	uint32_t flags = aFlags | nsIDocumentEncoder::OutputPreformatted
+		| nsIDocumentEncoder::OutputRaw
+		| nsIDocumentEncoder::OutputForPlainTextClipboardCopy
+		| nsIDocumentEncoder::OutputDropInvisibleBreak;
+
+
+	rv = docEncoder->Init(domDoc, mimeType, flags);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+
+	rv = docEncoder->SetNativeContainerNode(node);
+	NS_ENSURE_SUCCESS(rv, rv);
+	// SetSelection set the mime type to text/plain if the selection is inside a
+	// text widget.
+	rv = docEncoder->GetMimeType(mimeType);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	nsAutoString buf;
+	rv = docEncoder->EncodeToString(buf);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	rv = docEncoder->GetMimeType(mimeType);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	if (gCallback)
+		gCallback->DoGrammarCheck(buf);
+
+	return NS_OK;
+}
+
+
+NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsEditorGrammarCheck, nsEditorGrammarCheck::GetSingleton)
+
+// The following line defines a kNS_SAMPLE_CID CID variable.
+NS_DEFINE_NAMED_CID(NS_GRAMMARCHECK_CID);
+
+// Build a table of ClassIDs (CIDs) which are implemented by this module. CIDs
+// should be completely unique UUIDs.
+// each entry has the form { CID, service, factoryproc, constructorproc }
+// where factoryproc is usually NULL.
+static const mozilla::Module::CIDEntry kSampleCIDs[] = {
+    { &kNS_GRAMMARCHECK_CID, false, nullptr, nsEditorGrammarCheckConstructor },
+    { nullptr }
+};
+
+// Build a table which maps contract IDs to CIDs.
+// A contract is a string which identifies a particular set of functionality. In some
+// cases an extension component may override the contract ID of a builtin gecko component
+// to modify or extend functionality.
+static const mozilla::Module::ContractIDEntry kSampleContracts[] = {
+    { NS_GRAMMARCHECK_CONTRACTID, &kNS_GRAMMARCHECK_CID },
+    { nullptr }
+};
+
+// Category entries are category/key/value triples which can be used
+// to register contract ID as content handlers or to observe certain
+// notifications. Most modules do not need to register any category
+// entries: this is just a sample of how you'd do it.
+// @see nsICategoryManager for information on retrieving category data.
+static const mozilla::Module::CategoryEntry kSampleCategories[] = {
+    { "my-category", "my-key", NS_GRAMMARCHECK_CONTRACTID },
+    { nullptr }
+};
+
+static const mozilla::Module kSampleModule = {
+    mozilla::Module::kVersion,
+    kSampleCIDs,
+    kSampleContracts,
+    kSampleCategories
+};
+
+// The following line implements the one-and-only "NSModule" symbol exported from this
+// shared library.
+NSMODULE_DEFN(nsGrammarCheckModule) = &kSampleModule;
+
+// The following line implements the one-and-only "NSGetModule" symbol
+// for compatibility with mozilla 1.9.2. You should only use this
+// if you need a binary which is backwards-compatible and if you use
+// interfaces carefully across multiple versions.
+//NS_IMPL_MOZILLA192_NSGETMODULE(&kSampleModule)
\ No newline at end of file
diff --git a/editor/composer/nsEditorGrammarCheck.h b/editor/composer/nsEditorGrammarCheck.h
new file mode 100644
index 0000000..43cef02
--- /dev/null
+++ b/editor/composer/nsEditorGrammarCheck.h
@@ -0,0 +1,116 @@
+#ifndef __GRAMMARCHECK_IMPL_H__
+#define __GRAMMARCHECK_IMPL_H__
+
+#include "nsCOMPtr.h"                   // for nsCOMPtr
+#include "nsCycleCollectionParticipant.h"
+#include "nsIEditorGrammarCheck.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"                   // for nsString
+#include "nsTArray.h"                   // for nsTArray
+#include "nscore.h"    
+#include "../../extensions/spellcheck/src/mozInlineSpellWordUtil.h"
+#include "nsIArray.h"
+#include "nsIMutableArray.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIRunnable.h"
+
+class nsIEditor;
+//class mozInlineSpellWordUtil;
+
+#define NS_GRAMMARCHECK_CONTRACTID "@mozilla.org/grammarcheck;1"
+#define NS_GRAMMARCHECK_CLASSNAME "nsEditorGrammarCheck"
+#define NS_GRAMMARCHECK_CID { 0x8ac26150, 0x586f, 0x4b70, \
+  { 0x90, 0xdf, 0x07, 0x61, 0x0b, 0x80, 0xb4, 0x5f } }
+  
+#define GC_FACTORY_SINGLETON_IMPLEMENTATION(_className, _sInstance)        \
+_className * _className::_sInstance = nullptr;                                \
+																		   \
+already_AddRefed<_className>                                                 \
+_className::GetSingleton()                                                   \
+{                                                                            \
+if (_sInstance) {                                                          \
+  nsRefPtr<_className> ret = _sInstance;                                   \
+  return ret.forget();                                                     \
+}                                                                          \
+_sInstance = new _className();                                             \
+nsRefPtr<_className> ret = _sInstance;                                     \
+if (NS_FAILED(_sInstance->Init())) {                                       \
+  /* Null out ret before _sInstance so the destructor doesn't assert */    \
+  ret = nullptr;                                                           \
+  _sInstance = nullptr;                                                    \
+  return nullptr;                                                          \
+}                                                                          \
+return ret.forget();                                                       \
+}
+
+class nsEditorGrammarCheck final : public nsIEditorGrammarCheck
+{
+public:
+	nsEditorGrammarCheck();
+
+	struct GRAMMARERROR
+	{
+		int errorStart;
+		int errorEnd;
+		std::vector<nsString> suggestions;
+		std::vector<nsString> descriptions;
+		std::vector<bool> messageOnly;
+	};
+	
+	static already_AddRefed<nsEditorGrammarCheck> GetSingleton();
+	
+	static nsEditorGrammarCheck* GetGrammarCheckService()
+	{
+		if (!gGrammarCheckService) 
+		{
+			nsCOMPtr<nsIEditorGrammarCheck> serv = do_GetService(NS_GRAMMARCHECK_CONTRACTID);
+			NS_ENSURE_TRUE(serv, nullptr);
+			NS_ASSERTION(gGrammarCheckService, "Should have static instance pointer now");
+		}
+		return gGrammarCheckService;
+	}
+	
+	NS_IMETHODIMP Init();
+
+	void SetCurrentEditor(nsIEditor* editor);
+
+	NS_IMETHODIMP DoGrammarCheck();
+
+    /**
+     * This macro expands into a declaration of the nsISupports interface.
+     * Every XPCOM component needs to implement nsISupports, as it acts
+     * as the gateway to other interfaces this component implements.  You
+     * could manually declare QueryInterface, AddRef, and Release instead
+     * of using this macro, but why?
+     */
+    // nsISupports interface
+    NS_DECL_ISUPPORTS
+
+    /**
+     * This macro is defined in the nsISample.h file, and is generated
+     * automatically by the xpidl compiler.  It expands to
+     * declarations of all of the methods required to implement the
+     * interface.  xpidl will generate a NS_DECL_[INTERFACENAME] macro
+     * for each interface that it processes.
+     *
+     * The methods of nsISample are discussed individually below, but
+     * commented out (because this macro already defines them.)
+     */
+	 NS_DECL_NSIEDITORGRAMMARCHECK
+
+
+	nsCOMPtr<nsIEditor> mEditor;
+	nsCOMPtr<nsIDOMNode> mRootNode;
+	bool mCheckEnabled;
+	
+private:
+	~nsEditorGrammarCheck();
+
+	static nsEditorGrammarCheck* gGrammarCheckService;
+
+	nsCOMPtr<nsIEditorGrammarCheckCallback> gCallback;
+
+	std::vector<GRAMMARERROR> mErrors;
+};
+
+#endif
\ No newline at end of file
diff --git a/editor/composer/nsIEditorGrammarCheck.idl b/editor/composer/nsIEditorGrammarCheck.idl
new file mode 100644
index 0000000..38f9ee3
--- /dev/null
+++ b/editor/composer/nsIEditorGrammarCheck.idl
@@ -0,0 +1,30 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "nsIEditor.idl"
+
+interface nsIEditorGrammarCheckCallback;
+interface nsIArray;
+
+[scriptable, uuid(8ac26150-586f-4b70-90df-07610b80b45f)]
+interface nsIEditorGrammarCheck : nsISupports
+{
+	void registerAddon(in nsIEditorGrammarCheckCallback callback);
+	void errorsFound([array, size_is (count)] in uint32_t errorsStart, [array, size_is (count)] in uint32_t errorsEnd, in uint32_t count);
+	void addSuggestionForError(in uint32_t error, in AString suggestion, in AString description, [optional] in boolean messageOnly);
+	nsIArray getSuggestionsForOffset(in nsIEditor editor, in uint32_t aOffset);
+	nsIArray getDescriptionsForOffset(in nsIEditor editor, in uint32_t aOffset);
+	void doGrammarCorrection(in uint32_t aOffset, in uint32_t index);
+	void toggleEnabled();
+	boolean isGrammarCheckEnabled();
+	boolean isSuggestionMessageOnly(in uint32_t aOffset, in uint32_t suggestion);
+};
+
+[scriptable, function, uuid(a234f68f-425c-4f48-ba8b-abf49621e24a)]
+interface nsIEditorGrammarCheckCallback : nsISupports
+{
+	void doGrammarCheck(in AString text);
+};
\ No newline at end of file
diff --git a/editor/libeditor/nsEditor.cpp b/editor/libeditor/nsEditor.cpp
index 3b7913b..dbb4956 100644
--- a/editor/libeditor/nsEditor.cpp
+++ b/editor/libeditor/nsEditor.cpp
@@ -105,6 +105,7 @@
 #include "nsThreadUtils.h"              // for nsRunnable
 #include "nsTransactionManager.h"       // for nsTransactionManager
 #include "prtime.h"                     // for PR_Now
+#include "../composer/nsEditorGrammarCheck.h"
 
 class nsIOutputStream;
 class nsIParserService;
@@ -4998,6 +4999,9 @@ void
 nsEditor::OnFocus(nsIDOMEventTarget* aFocusEventTarget)
 {
   InitializeSelection(aFocusEventTarget);
+  
+  nsEditorGrammarCheck::GetGrammarCheckService()->SetCurrentEditor(this);
+  
   if (mInlineSpellChecker) {
     mInlineSpellChecker->UpdateCurrentDictionary();
   }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
index 72d861d..887e3ec 100644
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -2935,6 +2935,7 @@ nsFrame::HandlePress(nsPresContext* aPresContext,
       // the spellcheck, find and url formatting selections.
       //
       if (curDetail->mType != nsISelectionController::SELECTION_SPELLCHECK &&
+          curDetail->mType != nsISelectionController::SELECTION_GRAMMARCHECK &&
           curDetail->mType != nsISelectionController::SELECTION_FIND &&
           curDetail->mType != nsISelectionController::SELECTION_URLSECONDARY &&
           curDetail->mStart <= offsets.StartOffset() &&
diff --git a/layout/generic/nsSelection.cpp b/layout/generic/nsSelection.cpp
index 3bf5262..e4e03ae 100644
--- a/layout/generic/nsSelection.cpp
+++ b/layout/generic/nsSelection.cpp
@@ -269,6 +269,7 @@ GetIndexFromSelectionType(SelectionType aType)
     case nsISelectionController::SELECTION_ACCESSIBILITY: return 6; break;
     case nsISelectionController::SELECTION_FIND: return 7; break;
     case nsISelectionController::SELECTION_URLSECONDARY: return 8; break;
+	case nsISelectionController::SELECTION_GRAMMARCHECK: return 9; break;
     default:
       return -1; break;
     }
@@ -290,6 +291,7 @@ GetSelectionTypeFromIndex(int8_t aIndex)
     case 6: return nsISelectionController::SELECTION_ACCESSIBILITY; break;
     case 7: return nsISelectionController::SELECTION_FIND; break;
     case 8: return nsISelectionController::SELECTION_URLSECONDARY; break;
+	case 9: return nsISelectionController::SELECTION_GRAMMARCHECK; break;
     default:
       return nsISelectionController::SELECTION_NORMAL; break;
   }
@@ -4739,7 +4741,7 @@ Selection::RemoveRange(nsRange& aRange, ErrorResult& aRv)
     // into view. The spell-check selection, however, is created and destroyed
     // in the background. We don't want to scroll in this case or the view
     // might appear to be moving randomly (bug 337871).
-    if (mType != nsISelectionController::SELECTION_SPELLCHECK && cnt > 0)
+    if ((mType != nsISelectionController::SELECTION_SPELLCHECK && cnt > 0) || (mType != nsISelectionController::SELECTION_GRAMMARCHECK && cnt > 0))
       ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION);
   }
 
diff --git a/layout/generic/nsTextFrame.cpp b/layout/generic/nsTextFrame.cpp
index 1195f0f..443c6e3 100644
--- a/layout/generic/nsTextFrame.cpp
+++ b/layout/generic/nsTextFrame.cpp
@@ -333,7 +333,8 @@ public:
     eIndexSelRawText,
     eIndexConvText,
     eIndexSelConvText,
-    eIndexSpellChecker
+    eIndexSpellChecker,
+	eIndexGrammarChecker
   };
 
   static int32_t GetUnderlineStyleIndexForSelectionType(int32_t aSelectionType)
@@ -349,6 +350,8 @@ public:
         return eIndexSelConvText;
       case nsISelectionController::SELECTION_SPELLCHECK:
         return eIndexSpellChecker;
+	  case nsISelectionController::SELECTION_GRAMMARCHECK:
+		  return eIndexGrammarChecker;
       default:
         NS_WARNING("non-IME selection type");
         return eIndexRawInput;
@@ -387,7 +390,7 @@ protected:
     uint8_t mUnderlineStyle;
     float   mUnderlineRelativeSize;
   };
-  nsSelectionStyle mSelectionStyle[5];
+  nsSelectionStyle mSelectionStyle[6];
 
   // Color initializations
   void InitCommonColors();
@@ -3593,7 +3596,7 @@ nsTextPaintStyle::GetIMESelectionColors(int32_t  aIndex,
 {
   NS_ASSERTION(aForeColor, "aForeColor is null");
   NS_ASSERTION(aBackColor, "aBackColor is null");
-  NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
+  NS_ASSERTION(aIndex >= 0 && aIndex < 6, "Index out of range");
 
   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
   *aForeColor = selectionStyle->mTextColor;
@@ -3608,7 +3611,7 @@ nsTextPaintStyle::GetSelectionUnderlineForPaint(int32_t  aIndex,
 {
   NS_ASSERTION(aLineColor, "aLineColor is null");
   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
-  NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
+  NS_ASSERTION(aIndex >= 0 && aIndex < 6, "Index out of range");
 
   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
   if (selectionStyle->mUnderlineStyle == NS_STYLE_BORDER_STYLE_NONE ||
@@ -3807,13 +3810,18 @@ static StyleIDs SelectionStyleIDs[] = {
     LookAndFeel::eColorID_LAST_COLOR,
     LookAndFeel::eColorID_SpellCheckerUnderline,
     LookAndFeel::eIntID_SpellCheckerUnderlineStyle,
-    LookAndFeel::eFloatID_SpellCheckerUnderlineRelativeSize }
+    LookAndFeel::eFloatID_SpellCheckerUnderlineRelativeSize },
+	{ LookAndFeel::eColorID_LAST_COLOR,
+	LookAndFeel::eColorID_LAST_COLOR,
+	LookAndFeel::eColorID_GrammarCheckerUnderline,
+	LookAndFeel::eIntID_SpellCheckerUnderlineStyle,
+	LookAndFeel::eFloatID_GrammarCheckerUnderlineRelativeSize }
 };
 
 void
 nsTextPaintStyle::InitSelectionStyle(int32_t aIndex)
 {
-  NS_ASSERTION(aIndex >= 0 && aIndex < 5, "aIndex is invalid");
+  NS_ASSERTION(aIndex >= 0 && aIndex < 6, "aIndex is invalid");
   nsSelectionStyle* selectionStyle = &mSelectionStyle[aIndex];
   if (selectionStyle->mInit)
     return;
@@ -3874,7 +3882,7 @@ nsTextPaintStyle::GetSelectionUnderline(nsPresContext* aPresContext,
   NS_ASSERTION(aPresContext, "aPresContext is null");
   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
   NS_ASSERTION(aStyle, "aStyle is null");
-  NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
+  NS_ASSERTION(aIndex >= 0 && aIndex < 6, "Index out of range");
 
   StyleIDs& styleID = SelectionStyleIDs[aIndex];
 
@@ -5170,6 +5178,7 @@ ComputeDescentLimitForSelectionUnderline(nsPresContext* aPresContext,
 // Make sure this stays in sync with DrawSelectionDecorations below
 static const SelectionType SelectionTypesWithDecorations =
   nsISelectionController::SELECTION_SPELLCHECK |
+  nsISelectionController::SELECTION_GRAMMARCHECK |
   nsISelectionController::SELECTION_IME_RAWINPUT |
   nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT |
   nsISelectionController::SELECTION_IME_CONVERTEDTEXT |
@@ -5186,6 +5195,7 @@ ComputeSelectionUnderlineHeight(nsPresContext* aPresContext,
     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
       return aFontMetrics.underlineSize;
+	case nsISelectionController::SELECTION_GRAMMARCHECK:
     case nsISelectionController::SELECTION_SPELLCHECK: {
       // The thickness of the spellchecker underline shouldn't honor the font
       // metrics.  It should be constant pixels value which is decided from the
@@ -5327,6 +5337,7 @@ static void DrawSelectionDecorations(gfxContext* aContext,
       }
       break;
     }
+	case nsISelectionController::SELECTION_GRAMMARCHECK:
     case nsISelectionController::SELECTION_SPELLCHECK:
       if (!weDefineSelectionUnderline)
         return;
@@ -6597,7 +6608,8 @@ nsTextFrame::CombineSelectionUnderlineRect(nsPresContext* aPresContext,
     float relativeSize;
     int32_t index =
       nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(sd->mType);
-    if (sd->mType == nsISelectionController::SELECTION_SPELLCHECK) {
+    if (sd->mType == nsISelectionController::SELECTION_SPELLCHECK ||
+		sd->mType == nsISelectionController::SELECTION_GRAMMARCHECK) {
       if (!nsTextPaintStyle::GetSelectionUnderline(aPresContext, index, nullptr,
                                                    &relativeSize, &style)) {
         continue;
diff --git a/toolkit/locales/en-US/chrome/global/textcontext.dtd b/toolkit/locales/en-US/chrome/global/textcontext.dtd
index 62fbdfa..8e80f64 100644
--- a/toolkit/locales/en-US/chrome/global/textcontext.dtd
+++ b/toolkit/locales/en-US/chrome/global/textcontext.dtd
@@ -20,7 +20,10 @@
 <!ENTITY spellUndoAddToDictionary.label "Undo Add To Dictionary">
 <!ENTITY spellUndoAddToDictionary.accesskey "n">
 <!ENTITY spellCheckToggle.label "Check Spelling">
-<!ENTITY spellCheckToggle.accesskey "g">
+<!ENTITY spellCheckToggle.accesskey "s">
+<!ENTITY grammarCheckToggle.label "Check Grammar">
+<!ENTITY grammarCheckToggle.accesskey "g">
+<!ENTITY grammarNoSuggestion.label "(No Grammar Suggestions)">
 <!ENTITY spellNoSuggestions.label "(No Spelling Suggestions)">
 <!ENTITY spellDictionaries.label "Languages">
 <!ENTITY spellDictionaries.accesskey "l">
diff --git a/widget/LookAndFeel.h b/widget/LookAndFeel.h
index 870ef48..df6e7cf 100644
--- a/widget/LookAndFeel.h
+++ b/widget/LookAndFeel.h
@@ -59,6 +59,7 @@ public:
     eColorID_IMESelectedConvertedTextUnderline,
 
     eColorID_SpellCheckerUnderline,
+	eColorID_GrammarCheckerUnderline,
 
     // New CSS 2 color definitions
     eColorID_activeborder,
@@ -464,7 +465,8 @@ public:
 
     // The width/height ratio of the cursor. If used, the CaretWidth int metric
     // should be added to the calculated caret width.
-    eFloatID_CaretAspectRatio
+	eFloatID_CaretAspectRatio,
+	eFloatID_GrammarCheckerUnderlineRelativeSize
   };
 
   // These constants must be kept in 1:1 correspondence with the
diff --git a/widget/gtk/nsLookAndFeel.cpp b/widget/gtk/nsLookAndFeel.cpp
index fddfe01..2cae38c 100644
--- a/widget/gtk/nsLookAndFeel.cpp
+++ b/widget/gtk/nsLookAndFeel.cpp
@@ -177,6 +177,9 @@ nsLookAndFeel::NativeGetColor(ColorID aID, nscolor& aColor)
     case eColorID_SpellCheckerUnderline:
       aColor = NS_RGB(0xff, 0, 0);
       break;
+    case eColorID_GrammarCheckerUnderline:
+		aColor = NS_RGB(0, 0, 0xff);
+        return NS_OK;
 
 #if (MOZ_WIDGET_GTK == 2)
         // css2  http://www.w3.org/TR/REC-CSS2/ui.html#system-colors
@@ -688,7 +691,10 @@ nsLookAndFeel::GetFloatImpl(FloatID aID, float &aResult)
         break;
     case eFloatID_SpellCheckerUnderlineRelativeSize:
         aResult = 1.0f;
-        break;
+		break;
+	case eFloatID_GrammarCheckerUnderlineRelativeSize:
+		aResult = 1.0f;
+		break;
     case eFloatID_CaretAspectRatio:
         aResult = sCaretRatio;
         break;
diff --git a/widget/windows/nsLookAndFeel.cpp b/widget/windows/nsLookAndFeel.cpp
index 50e3a8b..a3b3359 100644
--- a/widget/windows/nsLookAndFeel.cpp
+++ b/widget/windows/nsLookAndFeel.cpp
@@ -153,6 +153,9 @@ nsLookAndFeel::NativeGetColor(ColorID aID, nscolor &aColor)
     case eColorID_SpellCheckerUnderline:
         aColor = NS_RGB(0xff, 0, 0);
         return NS_OK;
+    case eColorID_GrammarCheckerUnderline:
+		aColor = NS_RGB(0, 0, 0xff);
+        return NS_OK;
 
     // New CSS 2 Color definitions
     case eColorID_activeborder:
@@ -521,7 +524,10 @@ nsLookAndFeel::GetFloatImpl(FloatID aID, float &aResult)
         break;
     case eFloatID_SpellCheckerUnderlineRelativeSize:
         aResult = 1.0f;
-        break;
+		break;
+	case eFloatID_GrammarCheckerUnderlineRelativeSize:
+		aResult = 1.0f;
+		break;
     default:
         aResult = -1.0;
         res = NS_ERROR_FAILURE;
